/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hash.table;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class App {

  ///////////////////////////////////// challenge 31 ////////////////////////////////////
  public static String repeatedWord(String words) {
    String output = null;
    // first let us split string into words
    String[] wordsList = words.split(" ");

    // intilize hashtable
    HashTable<Integer> hashTable = new HashTable<>(wordsList.length);

    // loop over the words list and save it in the hash table
    for (int i = 0; i < wordsList.length; i++) {
      if (hashTable.contains(wordsList[i])) {
        output = wordsList[i];
        break;
      }
      hashTable.add(wordsList[i].toLowerCase(), i);
    }
    return output;
  }

  ///////////////////////////////////// challenge 32 ////////////////////////////////////
  public static List<Integer> treeIntersection(BinaryTree<Integer> binaryTree1, BinaryTree<Integer> binaryTree2) {
    List<Integer> output = new ArrayList<>();

    HashTable<Integer> hashTable = new HashTable<>(output.size() + 1);

    // traverse the trees and
    List<Integer> list1 = binaryTree1.inOrder(binaryTree1.root);
    List<Integer> list2 = binaryTree2.inOrder(binaryTree2.root);

    // add values to hashtable
    for (int i = 0; i < list1.size(); i++) {
      hashTable.add(list1.get(i), i);
      if (hashTable.contains(list2.get(i))) {
        output.add(list2.get(i));
      } else {
        hashTable.add(list2.get(i), i);
      }
    }
    return output;
  }

  ///////////////////////////////////// challenge 33 ////////////////////////////////////
  public static List<String> leftJoin(HashTable table1, HashTable table2) {
    List<String> output = new ArrayList<>();

    for (int i = 0; i < table1.size; i++) {
      if (table2.arrayHash[i].key != null) {
        if (table1.contains(table2.arrayHash[i].key)) {
          output.add("["+table2.arrayHash[i].key + "," + table2.arrayHash[i].value + "," + table1.get(table2.arrayHash[i].key)+"]");
        } else {
          output.add("["+table2.arrayHash[i].key + "," + table2.arrayHash[i].value + "," + "NULL"+"]");
        }
        if (table2.arrayHash[i].next != null) {
          if (table1.contains(table2.arrayHash[i].next.key)) {
            output.add("["+table2.arrayHash[i].next.key + "," + table2.arrayHash[i].next.value + "," + table1.get(table2.arrayHash[i].next.key)+"]");
          } else {
            output.add("["+table2.arrayHash[i].next.key + "," + table2.arrayHash[i].next.value + "," + "NULL"+"]");
          }
        }
      }
    }
    return output;
  }

  public static void main(String[] args) {
    ///////////////////////////////////// challenge 30 ////////////////////////////////////
//      HashTable<String> hashTable = new HashTable<>(10);
//
//      hashTable.add(11,"ahmad");
//      hashTable.add(12,"osama");
//      hashTable.add(12,"ibrahim");
//
//      System.out.println(hashTable.get(12));
//      System.out.println(hashTable.contains(11));
    ///////////////////////////////////// challenge 31////////////////////////////////////
//    String str1 ="Once upon a time, there was a brave princess who...";
//    System.out.println(repeatedWord(str1));

    ///////////////////////////////////// challenge 32 ////////////////////////////////////
//    BinaryTree<Integer> tree1 = new BinaryTree<>();
//    tree1.root = new TreeNode<Integer>(150);
//    tree1.root.left = new TreeNode<Integer>(100);
//    tree1.root.right = new TreeNode<Integer>(250);
//    tree1.root.left.left = new TreeNode<Integer>(75);
//    tree1.root.left.right = new TreeNode<Integer>(160);
//    tree1.root.left.right.left = new TreeNode<Integer>(125);
//    tree1.root.left.right.right = new TreeNode<Integer>(175);
//    tree1.root.right.left = new TreeNode<Integer>(200);
//    tree1.root.right.right = new TreeNode<Integer>(350);
//    tree1.root.right.right.left = new TreeNode<Integer>(300);
//    tree1.root.right.right.right = new TreeNode<Integer>(500);
//
//    BinaryTree<Integer> tree2 = new BinaryTree<>();
//    tree2.root = new TreeNode<Integer>(42);
//    tree2.root.left = new TreeNode<Integer>(100);
//    tree2.root.right = new TreeNode<Integer>(600);
//    tree2.root.left.left = new TreeNode<Integer>(15);
//    tree2.root.left.right = new TreeNode<Integer>(160);
//    tree2.root.left.right.left = new TreeNode<Integer>(125);
//    tree2.root.left.right.right = new TreeNode<Integer>(175);
//    tree2.root.right.left = new TreeNode<Integer>(200);
//    tree2.root.right.right = new TreeNode<Integer>(350);
//    tree2.root.right.right.left = new TreeNode<Integer>(4);
//    tree2.root.right.right.right = new TreeNode<Integer>(500);
//
//    System.out.println(treeIntersection(tree1,tree2));

    ///////////////////////////////////// challenge 33 ////////////////////////////////////
    HashTable<String> table1 = new HashTable<>(5);
    HashTable<String> table2 = new HashTable<>(5);

    table1.add("found", "enamored");
    table1.add("guide", "usher");
    table1.add("outfit", "garb");

    table2.add("found", "averse");
    table2.add("guide", "follow");
    table2.add("flow", "jam");

    System.out.println(leftJoin(table1, table2));

  }
}
